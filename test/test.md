## Ответы на тестовое задание [Ксении Судариковой](https://hh.ru/resume/78158e66ff0ee3997d0039ed1f347774524e44)

## Задача #1
>Реализация эффективного алгоритма для парсинга и сортировки больших данных

Решение – скрипт [DataSort](https://github.com/ksenia-sudarikova/scripts/blob/main/lib/data_sorter.rb)

Запуск из корня репозитория:
```bash
ruby bin/sort_data.rb <input_file> <output_file>
```

### Алгоритм
#### 1. Разбиение файла на части

  Делим большой файл отсортированные части по 200000 строк.

  Каждая часть сортируется в памяти с помощью [MergeSort](https://github.com/ksenia-sudarikova/scripts/blob/main/lib/merge_sort.rb) выполняется быстрее MaxHeap, но загружает данные в память, оптимизируем использование памяти загружая туда строки частями по 20000

#### 2. Слияние отсортированных файлов

  Используем [MaxHeap](https://github.com/ksenia-sudarikova/scripts/blob/main/lib/max_heap.rb) для сравнения строк из промежуточных отсортированных файлов.
  В памяти держим только текущие строки для сравнения, а не весь файл. Начинаем сравнивать максимальных amount для каждого файла.

#### 3. Мониторинг

  При запуске с --log-level=debug логируется, использование памяти и проверяется корректность сортировки

### Тесты:
  - для основного скрипта [DataSorter Specs](https://github.com/ksenia-sudarikova/scripts/blob/main/spec/data_sorter_spec.rb)
  - для реализации алгоритма сортировки [MergeSort](https://github.com/ksenia-sudarikova/scripts/blob/main/spec/merge_sort_spec.rb)
  - для реализации алгоритма сортировки [MaxHeap](https://github.com/ksenia-sudarikova/scripts/blob/main/spec/max_heap_spec.rb)

## Задача 2
>Дана строка s и словарь d, содержащий некие слова. Определите,можно ли строку s представить в последовательность разделенных пробелом слов, содержащихся в словаре d.

Реализация проверки [Dictionary](https://github.com/ksenia-sudarikova/scripts/blob/main/lib/dictionary.rb), [Тесты](https://github.com/ksenia-sudarikova/scripts/blob/main/spec/dictionary_spec.rb)

## Задача 3

> Описать шаги алгоритма для обработки данных геопозиций курьера с целью построения его маршрута на карте. .

### Ответ:

#### 1. Cбор и сохранение данных
  - координаты longitude, latitude
  - расстояние до предыдущей точки
  - время между точками
  - скорость перемещения
  - медианная скорость движения, по 5 точкам (по скользящему окну)
  - p90, 90-й процентиль скорости (для отсечения выбросов) — значение скорости, ниже которого находится 90% всех измерений скорости за рассматриваемый период, окно для подсчета процентиля лучше подогнать на реальных данных
  - статус точки, новые данные присваиваем статус, статус данных меняется после анализа последующих точке
  - направление движения

#### 2. Фильтрация выбросов
  Если
    - скорость резко превышает ожидаемую (например, p90x2)
    - расстояние до предыдущей точки >100м за 20 сек

  помечаем статус точки как unclear

#### 3. Сегментация поездок, выделяем поездки и остановки по следующим условиям:
  - новый сегмент если между точками прошло больше 10 минут после предыдущей точки
  - расстояние между последней и новой точкой превышает допустимое
  - остановка если подряд идёт серия точек со скоростью ниже порога, например, меньше 1 метра в секунду  и таких точек не меньше, например, 5

#### 4. Анализ и подтверждение точек
  Каждая pending-точка получает статус:
  - approved, если она не выбивается по скорости/направлению
  - unclear, если она выбивается из общего паттерна и не поддерживается последующими точками
  - pending если последующих данных не достаточно

#### 5. Сглаживание данных для построения маршрута на карте
Для approved точек, применяем методы сглаживания маршрута.

Для устранения GPS-скачков и резких поворотов при отрисовки маршрута, используем сглаживание: медианный фильтр по 3-5 точкам, убираем единичные шумы без искажения маршрута, либо другие графические методы

## Задача 4

>1. Описать шаги алгоритма для составления маршрута передвижения кладовщика по складу, начиная движение от стола, таким образом, чтобы он затратил минимально возможный путь..
> 2. Объясните почему решение оптимальное.

### Ответ, Алгоритм:
#### 1. Группируем ячейки по стеллажам
- (ряд, номер стеллажа) → список нужных ячеек, на полках
- внутри стеллажа — (полка, позиция на полке)

Это снижает количество точек для маршрута, упрощая задачу

#### 2. Построение графа
Узлы — стеллажи (ряд + номер стеллажа)
Рёбра — переходы между стеллажами вдоль стеллажа, с весом 3 шага (ширина полки), и переходы между рядами 3 шага (длина стеллажа + продвижение)

#### 3. Вычисление расстояний:
Для каждой пары стеллажей рассчитываем минимальный путь между стеллажами, и от стола до каждого стеллажа, с учётом разрешённых переходов, то есть движений только по проходам. Для расчета можно использовать алгоритм классический алгоритм Дейкстры

#### 4. Решение задачи коммивояжера (TSP) по стеллажам
На графе стеллажей ищем маршрут минимальной длины, посещающий все вершины и возвращающийся к столу

Для большого числа стеллажей применяем эвристики (жадный алгоритм ближайшего соседа, 2-opt и другие)

#### 5. Построение маршрута внутри каждого стеллажа
В выбранном порядке посещения стеллажей прокладываем путь по нужным ячейкам каждого стеллажа, обход по порядку

### Почему решение оптимальное
- Работа с стеллажами, а не ячейками, сокращает задачу до 2100 узлов (4200 если стеллажи двусторонние) вместо десятков тысяч
- Веса рёбер отражают реальные расстояния, проходы между рядами примерно равны проходу мимо стеллажа
- алгоритм Дейкстра + TSP даёт гарантированно короткий маршрут
Можно сравнить с таким вариантом "зигзага", обход всего склада за один раз, он не учитывает что все товары могут находиться рядом со столом

```
 ↑ → →  ↓     → → → →
 ↑   |  ↓  |  ↑  |   ↓
 ↑   |  ↓  |  ↑  |   ↓
 ↑   |  ↓  |  ↑  |   ↓
 ↑   |  ↓  |  ↑  |   ↓
 ↑   |  ↓  |  ↑  |   ↓
 ↑   |  ↓  |  ↑  |   ↓
 ↑   |  ↓  |  ↑  |   ↓
 ↑      → → → →      ↓
стол ← ← ← ← ← ← ← ← ←
```